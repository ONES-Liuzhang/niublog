# 网络相关

## TCP/IP网络协议

#### TCP/IP参考模型

总共四层：

1. 第一层 应用层
2. 第二层 传输层
3. 第三层 网络层
4. 第四层 链路层

> Tips：OSI模型一共有七层，TCP/IP模型在实现时把7层OSI模型合并为4层

##### 1. Http在哪一层？

​	应用层

##### 2.DNS在哪一层？

​	应用层，它提供 域名 到 IP地址 之间的解析服务

##### 3. TCP 传输层

如何保证数据可靠性？

* 3-1. 识别通信

  * 协议号 http、ftp 等，表示应用层使用的协议
  * 源IP
  * 源端口
  * 目标IP
  * 目标端口

  TCP使用socket建立连接，一个socket由 `源IP+源端口+目标IP+目标端口` 构成，（举例：针对服务器的一个服务，客户端机可以开启多个端口与服务器进行通信）

- 3-2. 三次握手、四次挥手  
  - 三次握手：

    为了保证通信的可靠性，客户端 和 服务器 都需要保证 **对方可以正常的发送/接收数据**，需要三次确认过程

  - 四次挥手：

    1. 第一次 主机1 的数据已经传输完毕，**提出** 要断开连接
    2. 第二次 主机2 接收到断开连接到请求，**回复**：知道了，同意关闭
    3. 第三次 主机2 确保数据传输完毕，向 主机1 **发送** 关闭连接的请求
    4. 第四次 主机1 收到请求后向 主机2 **回复** :收到你的请求
    5. 主机2 收到之后，关闭连接。 主机1 在等待 2ms 后没有收到回复，也关闭连接

##### 4. URI 和 URL

TCP/IP协议 对数据进行传输时，需要知道资源地址

- URI 用字符串标示了互联网资源，即**定位标识符**

- URL表示资源的地点（互联网上所处的位置），是URI的子集

说人话：

URI 和 URL 都是对资源进行定位，只是它们的定位方式不同而已，URI 相当于给了资源一个唯一的身份证号（名称），而 URL 直接用地址来表示资源（位置）

#### HTTP协议

HTTP协议 定义了一系列规则来**通信**并**解析数据**，对应的还有 ftp、mailto、telnet、file等协议

1. 请求要从客户端发出，最后服务端响应该请求并返回，服务端在没有收到请求之前不会发送响应
2. 请求报文的构成为 `Header` 、`Body`
3. HTTP 是不保存状态的协议（无状态协议）
4. 使用Cookie做状态管理（服务器根据Cookie识别客户端）
5. 通过URL来定位资源
6. 通过方法标识意图： GET、POST、PUT、DELETE、OPTIONS、TRACE、CONNECT、HEAD
   - 常用的是 GET、POST、OPTIONS
   - PUT 和 DELETE 没有验证机制，有安全问题，不常用
   - TRACE 容易引发 XST(Cross-Site Tracing，跨站追踪)攻击

##### HTTP

HTTP协议初始版本中，每一次HTTP通信都会连接、断开一次TCP连接，随着前端发展，这种模式会增大服务器压力，**HTTP1.1**出现了两个关键的新特性：

1. 持久化连接  🔥

   只要任意一端没有明确的提出要断开请求，那么这个TCP连接会一直保持

   HTTP1.1 默认开启持久化连接

   如果要断开请求，只需要在请求头中携带`Connection: close` 才会在请求完后关闭连接。

2. 管线化（pipelining）🔥

   即在同一个TCP连接里面，客户端可以同时发送多个请求，一般情况下没有开启

   缺点： 

   - 客户端可以发送多个请求
   - 但是服务端一次只能处理一个请求
   - **队头阻塞**

   > Q：为什么Chrome一次可以支持六个并发请求，一个TCP一次不是只能处理一个请求吗❓❓❓
   >
   > A：因为Chrome同时支持6个TCP连接

#### HTTP 1.0/1.1/2.0在并发请求上主要区别是什么

1. HTTP/1.0

   每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接.

2. HTTP/1.1

   默认采用持久连接(TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive).

   增加了管道机制，在同一个TCP连接里，允许多个请求同时发送，增加了并发性，进一步改善了HTTP协议的效率，但是同一个TCP连接里，所有的数据通信是按次序进行的。回应慢，会有许多请求排队，造成"队头堵塞"。

3. HTTP/2.0

   1. 双工模式，服务器也可以并发处理请求，解决队头阻塞问题
   2. 多路由复用，同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级
   3. 服务器推送，不经请求服务端主动向客户端发送数据

#### 创建一个HTTP服务

```js
// http-server.js
const http = require("http")
http.createServer((req, res) => {
  res.writeHead(200, {
    "Content-Type": "text/plain"
  })
  res.end("hello world")
})

http.listen(3000, '127.0.0.1')
```

#### http发送请求

```js
// http-client.js
const http = require("http")
const options = {
  hostname: "127.0.0.1",
  port: 3000,
  method: "GET",
  path: "/"
}
const req = http.request(options, (res) => {
  // 设置encoding
  res.setEncoding("utf8");
  res.on("data", (data) => {
    console.log(data)
  })
})

// 结束当前请求
req.end()
```

#### 一次完整的通信是什么样的？

1. 建立 TCP 连接

2. 客户端向服务端发送请求命令

   一旦建立了TCP连接，客户端就会向服务器发送请求命令；

   例如：GET/info HTTP/1.1

3. 客户端发送请求头信息

   以空白行来标识`Header`发送结束

4. 服务器应答

   客户端向服务器发出请求后，服务器会客户端返回响应；

   例如： HTTP/1.1 200 OK

   响应的第一部分是协议的版本号和响应状态码

5. 服务器返回响应头信息

6. 服务器向客户端发送数据

7. 关闭TCP连接

   如果客户端或者服务端在头部添加	了`Connection:keep-alive`，TCP 连接在发送后将仍然保持打开状态